select
    dt,
    variation,
    sum(members) over(partition by variation order by dt rows between unbounded preceding and current row) as members,
    sum(nsm_users) over(partition by variation order by dt rows between unbounded preceding and current row) as nsm_users,
    sum(subscriber_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as subscriber_cnt,
    sum(access_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as access_cnt,
    access_cnt / subscriber_cnt as `accesses per subscriber`,
    subscriber_cnt / members * 100 as `member -> subscriber, %`,
    sum(access_instant_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as access_instant_cnt,
    sum(access_ex_trial_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as access_ex_trial_cnt,
    sum(access_trial_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as access_trial_cnt,
    sum(trial_subscriber_cnt)  over(partition by variation order by dt rows between unbounded preceding and current row) as trial_subscriber_cnt,
    sum(charged_trial_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as charged_trial_cnt,
    sum(cancel_trial_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as cancel_trial_cnt,
    cancel_trial_cnt / access_trial_cnt * 100 as `trial -> cancel, %`,
    sum(trial_buyer_cnt)  over(partition by variation order by dt rows between unbounded preceding and current row) as trial_buyer_cnt,
    charged_trial_cnt / access_trial_cnt * 100 as `trial -> charge, %`,
    trial_buyer_cnt / trial_subscriber_cnt * 100 as `trial subscriber -> buyer, %`,
    sum(late_charged_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as late_charged_cnt,
    sum(buyer_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as buyer_cnt,
    buyer_cnt / subscriber_cnt * 100 as `subscriber -> buyer, %`,
    buyer_cnt / members * 100 as `member -> buyer, %`,
    sum(charge_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as charge_cnt,
    charge_cnt / access_cnt * 100 as  `subscription -> charge, %`,
    sum(cancel_14d_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as cancel_14d_cnt,
    cancel_14d_cnt / charge_cnt * 100 as `charge -> 14d cancel, %`,
    sum(cancel_1m_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as cancel_1m_cnt,
    cancel_1m_cnt / charge_cnt * 100 as `charge -> 1m cancel, %`,
    sum(b.revenue) over(partition by variation order by dt rows between unbounded preceding and current row) as revenue,
    sum(recurrent_charge_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as recurrent_charge_cnt,
    sum(recurrent_revenue) over(partition by variation order by dt rows between unbounded preceding and current row) as recurrent_revenue,
    sum(autorenew_on_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as autorenew_on_cnt,
    sum(trial_revenue) over(partition by variation order by dt rows between unbounded preceding and current row) as trial_revenue,
    sum(upgrade_cnt) over(partition by variation order by dt rows between unbounded preceding and current row) as upgrade_cnt,
    sum(upgrade_revenue) over(partition by variation order by dt rows between unbounded preceding and current row) as upgrade_revenue,
    revenue / buyer_cnt as arppu,
    revenue / charge_cnt as aov,
    revenue / members as exp_arpu,
    trial_revenue / members as exp_trial_arpu,
    (revenue - trial_revenue) / members as exp_instant_arpu,
    arrayFlatten(groupArray(prices) over(partition by variation order by dt rows between unbounded preceding and current row)) as prices,
    arrayFlatten(groupArray(prices_per_buyer) over(partition by variation order by dt rows between unbounded preceding and current row)) as prices_per_buyer,
    arrayMap(k -> (k, arraySum(arrayMap(v -> v.2, arrayFilter(x -> x.1 = k, prices_per_buyer)))), arrayDistinct(arrayMap(x -> x.1, prices_per_buyer))).2 AS grouped_sums
from
    bydate as b
